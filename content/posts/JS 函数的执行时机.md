---
title: "JS 函数的执行时机"
date: 2020-01-04T12:23:26+08:00
draft: false
---


![img1](/images/img1.jpg)

### 关于JS任务执行

众所周知，JS是一门单线程语言。那就像我们去银行办理业务，而单线程意味着只有一个办理窗口，那么每个人都要等前一个人办理完成后，再去办理。同理JS也是一样，JS任务要一个一个按顺序执行。那么问题来了，如果前一个任务执行时间过长，后一个任务也要等着，这样必然增加了网页的加载时间。因此聪明的程序员将任务分成两类

* 同步任务 
  
  上一件事情没有完成，继续处理上一件事情，只有上一件事情完成了，才会做下一件事情 --> JS中大部分都是同步编程
* 异步任务 
  
    规划要做一件事情，但是不是当前立马去执行这件事情，需要等一定的时间，这样的话，我们不会等着他执行，而是继续执行下面的操作

### JS 函数的执行时机

函数执行的时机不同，运行结果也不同。下面我们按同步任务和异步任务两种情况，分别解释函数执行时机。


## 同步
### 举几个栗子

问：打印出多少?

```
let a = 1
function fn() {console.log(a)}
```
执行步骤：
1. 声明变量a并赋值为1
2. 声明函数fn
3. 结束

答：函数未执行，不打印结果
```
let a = 1
function fn(){console.log(a)}
fn()
```
执行步骤：
1. 声明变量a并赋值为1
2. 声明函数fn
3. 执行fn() //打印出a
4. 结束

答：a的结果为1
```
let a = 1
function fn(){console.log(a)}
a = 2
fn()
```
执行步骤：
1. 声明变量a并赋值为1
2. 声明函数fn
3. 将2赋值给a
4. 执行fn() //打印出a
5. 结束

答：a的结果为2
```
let a = 1
function fn(){console.log(a)}
fn()
a = 2
```
执行步骤：
1. 声明变量a并赋值为1
2. 声明函数fn
3. 执行fn() //打印出a
4. 将2赋值为a
5. 结束

答：a的结果为1

通过上面几个例子可以看出，在同步任务中，确定函数运行的结果，需要关注函数执行的时间前的代码。因为后面的代码还没执行，不会影响函数的运行结果。

## 异步

要说异步，就不得不用大名鼎鼎的setTimeout来举例子了

```
let a = 1
function fn(){
    setTimeout(()=>{
        console.log(a)
    },0)
}
fn() // 2
a = 2
```
执行步骤：
1. 声明变量a并赋值为1
2. 声明函数fn
3. 执行fn() --> setTimeout()会过一会执行 -->跳过setTimeout()
4. 将2赋值为a
5. 执行setTimeout() //打印出a
6. 结束

a的结果为2

#### 再来看个经典面试题:
```
let i 
for( i = 0; i<6; i++){
    setTimeout(()=>{
        console.log(i)
    },0)
}
```
问i的结果为？

很简单，for循环总共执行6次。答案是0、1、2、3、4、5。

完美！

------------------------

完美的错过了正确答案

正确答案是6个6  //666666

我们可以这样理解：

for循环执行步骤：
1. i赋值为0
2. 判断i < 6 ?,满足进入第一循环
3. setTimeout()会过一会执行-->跳过setTimeout()继续执行
4. 执行i++，此时i的值为1
5. 判断i < 6 ?,满足进入第二循环
6. setTimeout()会过一会执行-->跳过setTimeout()继续执行
7. 执行i++，此时i的值为2
8. 省略...
16. 执行i++，此时i的值为6
17. 判断i < 6 ?,不满足跳出循环 
18. 执行第一次循环的setTimeout() //打印出a
19. 执行第二次循环的setTimeout() //打印出a
20. 执行第三次循环的setTimeout() //打印出a
21. 执行第四次循环的setTimeout() //打印出a
22. 执行第五次循环的setTimeout() //打印出a
23. 执行第六次循环的setTimeout() //打印出a
24. 结束

现在可以看出，由于setTimeout()的执行时间为for语句执行后，所以每次打印出的结果都为6

## setTimeout()的'过一会'执行究竟是多久呢？

上文中不止一次提到'过一会'了,那么'过一会'究竟是多久呢？

setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。也就是当同步任务的函数和语句执行完后，0秒或者立刻执行setTimeout(fn,0)。

## 那我就是想要打印0、1、2、3、4、5呢？

如果对于for循环使用setTimeout()的循行结果不满意，我们就是要打印0、1、2、3、4、5呢？

可以这样写：
```
for(let i = 0; i<6; i++){
    setTimeout(()=>{
        console.log(i)
    },0)
}
// 0 1 2 3 4 5
```
解释： 因为let变量的作用域只能在当前函数中，所以每次for循环生成的都是一个新的i， setTimeout里输出的i就是这个新的i，这个i是不会变化的，所以输出的就是正常的。

因为在for语句里用let声明变量是局部变量遵循块作用域，所以每次for循环执行时都会生成一个单独的作用域，也会生成一个新的i，相当于有6个 i。 此时，每次执行setTimeout()时都会打印出对应的i，打印结果就是0、1、2、3、4、5了。

#### 我们还可以这样解决

* 闭包
```
let i 
for(i = 0; i<6; i++){
  !function(j){
      setTimeout(()=>{
        console.log(j)
      },0)
  }(i)
}
```
* 利用 setTimeout 的第三个参数,将i传进去
```
let i 
for(i = 0; i<6; i++){
  !function(j){
      setTimeout(()=>{
        console.log(j)
      },0)
  }(i)
}
```
* 利用 const 关键字
```
let i
for(i = 0; i<6; i++){
    const x = i
    setTimeout(()=>{
      console.log(x)
    })
}
```